<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="16" failures="31" skipped="0" tests="78" time="122.249" timestamp="2025-09-20T10:25:10.036424+00:00" hostname="eee96253007c"><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_complete_scheduling_workflow" time="0.162"><failure message="AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'">self = &lt;test_agent_workflow.TestAgentWorkflow object at 0xffff7f9f2710&gt;

    @pytest.mark.asyncio
    async def test_complete_scheduling_workflow(self):
        """Test complete meeting scheduling workflow."""
        # Mock agent core
&gt;       with patch('agent_core.CalendarSchedulerAgent') as mock_agent_class:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_agent_workflow.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0xffff7d4f66d0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'

/usr/local/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_room_availability_workflow" time="0.001"><failure message="AttributeError: &lt;module 'services.calendar_service' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/services/calendar_service.py'&gt; does not have the attribute 'SyntheticCalendarService'">self = &lt;test_agent_workflow.TestAgentWorkflow object at 0xffff7f9f2c10&gt;

    @pytest.mark.asyncio
    async def test_room_availability_workflow(self):
        """Test room availability checking workflow."""
&gt;       with patch('services.calendar_service.SyntheticCalendarService') as mock_service:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_agent_workflow.py:84: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0xffff7d287cb0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'services.calendar_service' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/services/calendar_service.py'&gt; does not have the attribute 'SyntheticCalendarService'

/usr/local/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_mcp_client_workflow" time="0.002" /><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_permissions_workflow" time="0.004"><failure message="AttributeError: module 'services' has no attribute 'simple_permissions'">self = &lt;test_agent_workflow.TestAgentWorkflow object at 0xffff7f8e0770&gt;

    @pytest.mark.asyncio
    async def test_permissions_workflow(self):
        """Test permissions checking workflow."""
&gt;       with patch('services.simple_permissions.SimplePermissions') as mock_perms_class:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_agent_workflow.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.13/unittest/mock.py:1481: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'services.simple_permissions'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
                     ^^^^^^^^^^^^^^^^^^
E           AttributeError: module 'services' has no attribute 'simple_permissions'

/usr/local/lib/python3.13/pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_evaluation_workflow" time="0.001" /><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_error_handling_workflow" time="0.001"><failure message="AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'">self = &lt;test_agent_workflow.TestAgentWorkflow object at 0xffff7f8dc5a0&gt;

    @pytest.mark.asyncio
    async def test_error_handling_workflow(self):
        """Test error handling throughout the workflow."""
&gt;       with patch('agent_core.CalendarSchedulerAgent') as mock_agent_class:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_agent_workflow.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0xffff7d2fab30&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'

/usr/local/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_concurrent_requests_workflow" time="0.001"><failure message="AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'">self = &lt;test_agent_workflow.TestAgentWorkflow object at 0xffff7f8dc7c0&gt;

    @pytest.mark.asyncio
    async def test_concurrent_requests_workflow(self):
        """Test handling of concurrent requests."""
&gt;       with patch('agent_core.CalendarSchedulerAgent') as mock_agent_class:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_agent_workflow.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0xffff7d1f4050&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'

/usr/local/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_stream_handler_workflow" time="0.002" /><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_full_integration_workflow" time="0.001"><failure message="AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'">self = &lt;test_agent_workflow.TestAgentWorkflow object at 0xffff7f9bbb50&gt;

    @pytest.mark.asyncio
    async def test_full_integration_workflow(self):
        """Test complete integration of all components."""
        # Mock all major components
&gt;       with patch('agent_core.CalendarSchedulerAgent') as mock_agent_class, \
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             patch('services.mcp_client.CalendarMCPClient') as mock_mcp_class, \
             patch('services.simple_permissions.SimplePermissions') as mock_perms_class, \
             patch('evaluation.real_time_evaluator.RealTimeEvaluator') as mock_eval_class:

tests/integration/test_agent_workflow.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0xffff7d1f5470&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'

/usr/local/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_failure_recovery_workflow" time="0.001"><failure message="AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'">self = &lt;test_agent_workflow.TestAgentWorkflow object at 0xffff7f8d86e0&gt;

    @pytest.mark.asyncio
    async def test_failure_recovery_workflow(self):
        """Test workflow recovery from failures."""
&gt;       with patch('agent_core.CalendarSchedulerAgent') as mock_agent_class:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_agent_workflow.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0xffff7d2f9c50&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'

/usr/local/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_performance_workflow" time="0.001"><failure message="AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'">self = &lt;test_agent_workflow.TestAgentWorkflow object at 0xffff7f8d88c0&gt;

    @pytest.mark.asyncio
    async def test_performance_workflow(self):
        """Test workflow performance characteristics."""
        import time
    
&gt;       with patch('agent_core.CalendarSchedulerAgent') as mock_agent_class:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_agent_workflow.py:346: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0xffff7d2f8bb0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'CalendarSchedulerAgent'

/usr/local/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.integration.test_agent_workflow.TestAgentWorkflow" name="test_data_validation_workflow" time="0.001"><failure message="AttributeError: &lt;module 'services.calendar_service' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/services/calendar_service.py'&gt; does not have the attribute 'SyntheticCalendarService'">self = &lt;test_agent_workflow.TestAgentWorkflow object at 0xffff7f8c3930&gt;

    @pytest.mark.asyncio
    async def test_data_validation_workflow(self):
        """Test data validation throughout the workflow."""
&gt;       with patch('services.calendar_service.SyntheticCalendarService') as mock_service:
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_agent_workflow.py:368: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0xffff7d287770&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'services.calendar_service' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/services/calendar_service.py'&gt; does not have the attribute 'SyntheticCalendarService'

/usr/local/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.integration.test_calendar_integration.TestCalendarIntegration" name="test_end_to_end_event_creation" time="0.001"><error message="failed on setup with &quot;file /workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_calendar_integration.py, line 26&#10;      @pytest.mark.asyncio&#10;      async def test_end_to_end_event_creation(self, sample_events, performance_tracker, save_test_artifact):&#10;          &quot;&quot;&quot;Test complete event creation workflow.&quot;&quot;&quot;&#10;          event_data = sample_events[0]&#10;&#10;          with patch('services.compat_sql_store.create_event') as mock_create, \&#10;               patch('services.compat_sql_store.list_events') as mock_list:&#10;&#10;              # Track performance&#10;              start_time = time.time()&#10;&#10;              # Mock successful creation&#10;              mock_create.return_value = {&quot;success&quot;: True, &quot;event_id&quot;: &quot;new-event-123&quot;}&#10;              mock_list.return_value = {&quot;events&quot;: [event_data]}&#10;&#10;              # Create event&#10;              create_result = await async_create_event(event_data)&#10;              create_time = time.time()&#10;&#10;              assert create_result[&quot;success&quot;] is True&#10;&#10;              # Verify event exists&#10;              list_result = await async_list_events(&quot;room1&quot;)&#10;              end_time = time.time()&#10;&#10;              assert len(list_result[&quot;events&quot;]) == 1&#10;              assert list_result[&quot;events&quot;][0][&quot;title&quot;] == event_data[&quot;title&quot;]&#10;&#10;              # Track performance metrics&#10;              performance_tracker(&quot;event_creation&quot;, start_time, create_time)&#10;              performance_tracker(&quot;event_listing&quot;, create_time, end_time)&#10;              performance_tracker(&quot;full_workflow&quot;, start_time, end_time)&#10;&#10;              # Save test results for thesis&#10;              save_test_artifact(&quot;event_creation_workflow&quot;, {&#10;                  &quot;test_type&quot;: &quot;integration&quot;,&#10;                  &quot;workflow&quot;: &quot;end_to_end_event_creation&quot;,&#10;                  &quot;performance&quot;: {&#10;                      &quot;creation_duration&quot;: create_time - start_time,&#10;                      &quot;total_duration&quot;: end_time - start_time&#10;                  },&#10;                  &quot;results&quot;: {&#10;                      &quot;create_success&quot;: create_result[&quot;success&quot;],&#10;                      &quot;events_found&quot;: len(list_result[&quot;events&quot;])&#10;                  }&#10;              })&#10;E       fixture 'save_test_artifact' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, artifact_dir, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, in_memory_db, include_metadata_in_junit_xml, metadata, mock_agent, mock_agent_thread, mock_azure_client, mock_calendar_mcp_client, mock_default_azure_credential, mock_httpx_client, mock_permissions, mock_stream_event_handler, mock_utilities, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_tracker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_calendar_events, sample_events, sample_rooms, sample_scheduling_request, session_mocker, temp_db_file, temp_directory, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_calendar_integration.py:26&quot;">file /workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_calendar_integration.py, line 26
      @pytest.mark.asyncio
      async def test_end_to_end_event_creation(self, sample_events, performance_tracker, save_test_artifact):
          """Test complete event creation workflow."""
          event_data = sample_events[0]

          with patch('services.compat_sql_store.create_event') as mock_create, \
               patch('services.compat_sql_store.list_events') as mock_list:

              # Track performance
              start_time = time.time()

              # Mock successful creation
              mock_create.return_value = {"success": True, "event_id": "new-event-123"}
              mock_list.return_value = {"events": [event_data]}

              # Create event
              create_result = await async_create_event(event_data)
              create_time = time.time()

              assert create_result["success"] is True

              # Verify event exists
              list_result = await async_list_events("room1")
              end_time = time.time()

              assert len(list_result["events"]) == 1
              assert list_result["events"][0]["title"] == event_data["title"]

              # Track performance metrics
              performance_tracker("event_creation", start_time, create_time)
              performance_tracker("event_listing", create_time, end_time)
              performance_tracker("full_workflow", start_time, end_time)

              # Save test results for thesis
              save_test_artifact("event_creation_workflow", {
                  "test_type": "integration",
                  "workflow": "end_to_end_event_creation",
                  "performance": {
                      "creation_duration": create_time - start_time,
                      "total_duration": end_time - start_time
                  },
                  "results": {
                      "create_success": create_result["success"],
                      "events_found": len(list_result["events"])
                  }
              })
E       fixture 'save_test_artifact' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, artifact_dir, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, in_memory_db, include_metadata_in_junit_xml, metadata, mock_agent, mock_agent_thread, mock_azure_client, mock_calendar_mcp_client, mock_default_azure_credential, mock_httpx_client, mock_permissions, mock_stream_event_handler, mock_utilities, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_tracker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_calendar_events, sample_events, sample_rooms, sample_scheduling_request, session_mocker, temp_db_file, temp_directory, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_calendar_integration.py:26</error></testcase><testcase classname="tests.integration.test_calendar_integration.TestCalendarIntegration" name="test_room_availability_workflow" time="15.160"><failure message="pyodbc.OperationalError: ('HYT00', '[HYT00] [Microsoft][ODBC Driver 18 for SQL Server]Login timeout expired (0) (SQLDriverConnect)')">self = &lt;test_calendar_integration.TestCalendarIntegration object at 0xffff7f9f2d50&gt;

    @pytest.mark.asyncio
    async def test_room_availability_workflow(self):
        """Test room availability checking workflow."""
        room_id = "room1"
        start_time = "2024-12-01T10:00:00Z"
        end_time = "2024-12-01T11:00:00Z"
    
        with patch('services.compat_sql_store.check_availability') as mock_check, \
             patch('services.compat_sql_store.get_rooms') as mock_rooms:
    
            # Setup room data
            mock_rooms.return_value = {"rooms": [{"id": room_id, "name": "Conference Room A"}]}
            mock_check.return_value = True
    
            # Check room availability
&gt;           rooms = await async_get_rooms()
                    ^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_calendar_integration.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
services/async_sql_store.py:11: in async_get_rooms
    return await asyncio.to_thread(get_rooms)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.13/asyncio/threads.py:25: in to_thread
    return await loop.run_in_executor(None, func_call)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.13/concurrent/futures/thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
services/compat_sql_store.py:12: in get_rooms
    with _conn() as cn, cn.cursor() as cur:
         ^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _conn():
&gt;       return pyodbc.connect(CS)
               ^^^^^^^^^^^^^^^^^^
E       pyodbc.OperationalError: ('HYT00', '[HYT00] [Microsoft][ODBC Driver 18 for SQL Server]Login timeout expired (0) (SQLDriverConnect)')

services/compat_sql_store.py:8: OperationalError</failure></testcase><testcase classname="tests.integration.test_calendar_integration.TestCalendarIntegration" name="test_conflict_detection_integration" time="15.138"><failure message="pyodbc.OperationalError: ('HYT00', '[HYT00] [Microsoft][ODBC Driver 18 for SQL Server]Login timeout expired (0) (SQLDriverConnect)')">self = &lt;test_calendar_integration.TestCalendarIntegration object at 0xffff7f8e08a0&gt;
sample_events = [{'attendees': 'team@company.com', 'description': 'Daily team standup', 'end_time': '2024-12-01T09:30:00Z', 'id': 'eve...s': 'team@company.com', 'description': 'Monthly team lunch', 'end_time': '2024-12-02T13:00:00Z', 'id': 'event-3', ...}]

    @pytest.mark.asyncio
    async def test_conflict_detection_integration(self, sample_events):
        """Test that the system detects scheduling conflicts."""
        event1 = sample_events[0]
    
        # Create overlapping event
        event2 = event1.copy()
        event2["id"] = "event-2"
        event2["title"] = "Conflicting Meeting"
        event2["start_time"] = "2024-12-01T09:15:00Z"  # Overlaps with event1
    
        with patch('services.compat_sql_store.check_availability') as mock_check, \
             patch('services.compat_sql_store.create_event') as mock_create:
    
            # First event succeeds
            mock_check.return_value = True
            mock_create.return_value = {"success": True, "event_id": "event-1"}
    
&gt;           result1 = await async_create_event(event1)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_calendar_integration.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
services/async_sql_store.py:21: in async_create_event
    return await asyncio.to_thread(create_event, ev)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.13/asyncio/threads.py:25: in to_thread
    return await loop.run_in_executor(None, func_call)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.13/concurrent/futures/thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
services/compat_sql_store.py:34: in create_event
    with _conn() as cn, cn.cursor() as cur:
         ^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _conn():
&gt;       return pyodbc.connect(CS)
               ^^^^^^^^^^^^^^^^^^
E       pyodbc.OperationalError: ('HYT00', '[HYT00] [Microsoft][ODBC Driver 18 for SQL Server]Login timeout expired (0) (SQLDriverConnect)')

services/compat_sql_store.py:8: OperationalError</failure></testcase><testcase classname="tests.integration.test_calendar_integration.TestCalendarIntegration" name="test_multi_room_scheduling" time="15.195"><failure message="pyodbc.OperationalError: ('HYT00', '[HYT00] [Microsoft][ODBC Driver 18 for SQL Server]Login timeout expired (0) (SQLDriverConnect)')">self = &lt;test_calendar_integration.TestCalendarIntegration object at 0xffff7f8e09d0&gt;

    @pytest.mark.asyncio
    async def test_multi_room_scheduling(self):
        """Test scheduling across multiple rooms."""
        rooms_data = {
            "rooms": [
                {"id": "room1", "name": "Conference Room A"},
                {"id": "room2", "name": "Conference Room B"},
                {"id": "room3", "name": "Meeting Room C"}
            ]
        }
    
        with patch('services.compat_sql_store.get_rooms') as mock_rooms, \
             patch('services.compat_sql_store.check_availability') as mock_check:
    
            mock_rooms.return_value = rooms_data
    
            # Room1 not available, Room2 available
            mock_check.side_effect = [False, True, True]
    
&gt;           rooms = await async_get_rooms()
                    ^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_calendar_integration.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
services/async_sql_store.py:11: in async_get_rooms
    return await asyncio.to_thread(get_rooms)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.13/asyncio/threads.py:25: in to_thread
    return await loop.run_in_executor(None, func_call)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.13/concurrent/futures/thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
services/compat_sql_store.py:12: in get_rooms
    with _conn() as cn, cn.cursor() as cur:
         ^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _conn():
&gt;       return pyodbc.connect(CS)
               ^^^^^^^^^^^^^^^^^^
E       pyodbc.OperationalError: ('HYT00', '[HYT00] [Microsoft][ODBC Driver 18 for SQL Server]Login timeout expired (0) (SQLDriverConnect)')

services/compat_sql_store.py:8: OperationalError</failure></testcase><testcase classname="tests.integration.test_calendar_integration.TestCalendarIntegration" name="test_database_transaction_integrity" time="15.170" /><testcase classname="tests.integration.test_calendar_integration.TestCalendarIntegration" name="test_comprehensive_workflow_with_artifacts" time="15.175"><failure message="pyodbc.OperationalError: ('HYT00', '[HYT00] [Microsoft][ODBC Driver 18 for SQL Server]Login timeout expired (0) (SQLDriverConnect)')">self = &lt;test_calendar_integration.TestCalendarIntegration object at 0xffff7f8dc490&gt;
sample_events = [{'attendees': 'team@company.com', 'description': 'Daily team standup', 'end_time': '2024-12-01T09:30:00Z', 'id': 'eve...s': 'team@company.com', 'description': 'Monthly team lunch', 'end_time': '2024-12-02T13:00:00Z', 'id': 'event-3', ...}]
artifact_dir = PosixPath('reports/artifacts')
performance_tracker = &lt;conftest.performance_tracker.&lt;locals&gt;.PerformanceTracker object at 0xffff7d3f3380&gt;

    @pytest.mark.asyncio
    async def test_comprehensive_workflow_with_artifacts(self, sample_events, artifact_dir, performance_tracker):
        """Test complete workflow with comprehensive artifact collection."""
        from tests.conftest import save_artifact
    
        # Start overall performance tracking
        performance_tracker.start_timer("complete_workflow")
    
        event_data = sample_events[0]
    
        with patch('services.compat_sql_store.create_event') as mock_create, \
             patch('services.compat_sql_store.list_events') as mock_list, \
             patch('services.compat_sql_store.check_availability') as mock_check:
    
            # Performance tracking for availability check
            performance_tracker.start_timer("availability_check")
    
            # Mock availability check
            mock_check.return_value = True
&gt;           availability = await async_check_availability("room1", "2024-12-01T10:00:00Z", "2024-12-01T11:00:00Z")
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/integration/test_calendar_integration.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
services/async_sql_store.py:36: in async_check_availability
    return await asyncio.to_thread(check_availability, calendar_id, start_iso, end_iso, exclude_event_id)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.13/asyncio/threads.py:25: in to_thread
    return await loop.run_in_executor(None, func_call)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.13/concurrent/futures/thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
services/compat_sql_store.py:84: in check_availability
    with _conn() as cn, cn.cursor() as cur:
         ^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _conn():
&gt;       return pyodbc.connect(CS)
               ^^^^^^^^^^^^^^^^^^
E       pyodbc.OperationalError: ('HYT00', '[HYT00] [Microsoft][ODBC Driver 18 for SQL Server]Login timeout expired (0) (SQLDriverConnect)')

services/compat_sql_store.py:8: OperationalError</failure></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_home_route" time="0.042"><failure message="assert 302 == 200&#10; +  where 302 = &lt;WrapperTestResponse streamed [302 FOUND]&gt;.status_code">self = &lt;test_web_server_integration.TestWebServerIntegration object at 0xffff7da6cb90&gt;
client = &lt;FlaskClient &lt;Flask 'web_server'&gt;&gt;

    def test_home_route(self, client):
        """Test home route responds correctly."""
        response = client.get('/')
&gt;       assert response.status_code == 200
E       assert 302 == 200
E        +  where 302 = &lt;WrapperTestResponse streamed [302 FOUND]&gt;.status_code

tests/integration/test_web_server_integration.py:41: AssertionError</failure></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_login_route" time="15.180" /><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_api_org_structure" time="0.019"><error message="failed on setup with &quot;file /workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_web_server_integration.py, line 50&#10;      @patch('services.compat_sql_store.get_org_structure')&#10;      def test_api_org_structure(self, mock_org, authenticated_client, save_test_artifact):&#10;E       fixture 'save_test_artifact' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, artifact_dir, authenticated_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, client, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, in_memory_db, include_metadata_in_junit_xml, metadata, mock_agent, mock_agent_thread, mock_azure_client, mock_calendar_mcp_client, mock_default_azure_credential, mock_httpx_client, mock_permissions, mock_stream_event_handler, mock_utilities, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_tracker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_calendar_events, sample_events, sample_rooms, sample_scheduling_request, session_mocker, temp_db_file, temp_directory, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_web_server_integration.py:50&quot;">file /workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_web_server_integration.py, line 50
      @patch('services.compat_sql_store.get_org_structure')
      def test_api_org_structure(self, mock_org, authenticated_client, save_test_artifact):
E       fixture 'save_test_artifact' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, artifact_dir, authenticated_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, client, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, in_memory_db, include_metadata_in_junit_xml, metadata, mock_agent, mock_agent_thread, mock_azure_client, mock_calendar_mcp_client, mock_default_azure_credential, mock_httpx_client, mock_permissions, mock_stream_event_handler, mock_utilities, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_tracker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_calendar_events, sample_events, sample_rooms, sample_scheduling_request, session_mocker, temp_db_file, temp_directory, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_web_server_integration.py:50</error></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_api_rooms" time="0.001"><error message="failed on setup with &quot;file /workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_web_server_integration.py, line 82&#10;      @patch('services.async_sql_store.async_get_rooms')&#10;      def test_api_rooms(self, mock_rooms, authenticated_client, save_test_artifact):&#10;E       fixture 'save_test_artifact' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, artifact_dir, authenticated_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, client, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, in_memory_db, include_metadata_in_junit_xml, metadata, mock_agent, mock_agent_thread, mock_azure_client, mock_calendar_mcp_client, mock_default_azure_credential, mock_httpx_client, mock_permissions, mock_stream_event_handler, mock_utilities, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_tracker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_calendar_events, sample_events, sample_rooms, sample_scheduling_request, session_mocker, temp_db_file, temp_directory, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_web_server_integration.py:82&quot;">file /workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_web_server_integration.py, line 82
      @patch('services.async_sql_store.async_get_rooms')
      def test_api_rooms(self, mock_rooms, authenticated_client, save_test_artifact):
E       fixture 'save_test_artifact' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, artifact_dir, authenticated_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, client, cov, doctest_namespace, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, in_memory_db, include_metadata_in_junit_xml, metadata, mock_agent, mock_agent_thread, mock_azure_client, mock_calendar_mcp_client, mock_default_azure_credential, mock_httpx_client, mock_permissions, mock_stream_event_handler, mock_utilities, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_tracker, pytestconfig, record_property, record_testsuite_property, record_xml_attribute, recwarn, sample_calendar_events, sample_events, sample_rooms, sample_scheduling_request, session_mocker, temp_db_file, temp_directory, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/tests/integration/test_web_server_integration.py:82</error></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_api_events" time="0.008"><failure message="assert 404 == 200&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code">self = &lt;test_web_server_integration.TestWebServerIntegration object at 0xffff7da4d490&gt;
mock_events = &lt;AsyncMock name='async_list_events' id='281472780591728'&gt;
authenticated_client = &lt;FlaskClient &lt;Flask 'web_server'&gt;&gt;

    @patch('services.async_sql_store.async_list_events')
    def test_api_events(self, mock_events, authenticated_client):
        """Test events API endpoint."""
        mock_events.return_value = {
            "events": [
                {
                    "id": "event1",
                    "title": "Test Meeting",
                    "start_time": "2024-12-01T10:00:00Z",
                    "end_time": "2024-12-01T11:00:00Z"
                }
            ]
        }
    
        response = authenticated_client.get('/api/events')
&gt;       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code

tests/integration/test_web_server_integration.py:131: AssertionError</failure></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_api_create_event" time="0.005"><failure message="assert 404 == 200&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code">self = &lt;test_web_server_integration.TestWebServerIntegration object at 0xffff7dbd7020&gt;
mock_create = &lt;AsyncMock name='async_create_event' id='281472780583328'&gt;
authenticated_client = &lt;FlaskClient &lt;Flask 'web_server'&gt;&gt;

    @patch('services.async_sql_store.async_create_event')
    def test_api_create_event(self, mock_create, authenticated_client):
        """Test event creation API endpoint."""
        mock_create.return_value = {"success": True, "event_id": "new-event-123"}
    
        event_data = {
            "title": "New Meeting",
            "description": "Test meeting",
            "start_time": "2024-12-01T14:00:00Z",
            "end_time": "2024-12-01T15:00:00Z",
            "attendees": "user1@test.com,user2@test.com",
            "room_id": "room1"
        }
    
        response = authenticated_client.post('/api/events',
                                           data=json.dumps(event_data),
                                           content_type='application/json')
    
&gt;       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code

tests/integration/test_web_server_integration.py:155: AssertionError</failure></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_api_unauthorized_access" time="0.003"><failure message="assert 404 in [302, 401]&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code">self = &lt;test_web_server_integration.TestWebServerIntegration object at 0xffff7dbd7130&gt;
client = &lt;FlaskClient &lt;Flask 'web_server'&gt;&gt;

    def test_api_unauthorized_access(self, client):
        """Test API endpoints require authentication."""
        endpoints = ['/api/events', '/api/rooms', '/api/org-structure']
    
        for endpoint in endpoints:
            response = client.get(endpoint)
            # Should either redirect to login or return 401
&gt;           assert response.status_code in [302, 401]
E           assert 404 in [302, 401]
E            +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code

tests/integration/test_web_server_integration.py:167: AssertionError</failure></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_api_check_availability" time="0.002"><failure message="assert 404 == 200&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code">self = &lt;test_web_server_integration.TestWebServerIntegration object at 0xffff7f9bb750&gt;
mock_check = &lt;AsyncMock name='async_check_availability' id='281472780594752'&gt;
authenticated_client = &lt;FlaskClient &lt;Flask 'web_server'&gt;&gt;

    @patch('services.async_sql_store.async_check_availability')
    def test_api_check_availability(self, mock_check, authenticated_client):
        """Test availability checking API endpoint."""
        mock_check.return_value = True
    
        data = {
            "room_id": "room1",
            "start_time": "2024-12-01T10:00:00Z",
            "end_time": "2024-12-01T11:00:00Z"
        }
    
        response = authenticated_client.post('/api/check-availability',
                                           data=json.dumps(data),
                                           content_type='application/json')
    
&gt;       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code

tests/integration/test_web_server_integration.py:184: AssertionError</failure></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_chat_endpoint" time="0.001"><failure message="AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'chat'">args = (&lt;test_web_server_integration.TestWebServerIntegration object at 0xffff7dbca850&gt;,)
keywargs = {'authenticated_client': &lt;FlaskClient &lt;Flask 'web_server'&gt;&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/local/lib/python3.13/unittest/mock.py:1423: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.13/contextlib.py:141: in __enter__
    return next(self.gen)
           ^^^^^^^^^^^^^^
/usr/local/lib/python3.13/unittest/mock.py:1405: in decoration_helper
    arg = exit_stack.enter_context(patching)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.13/contextlib.py:530: in enter_context
    result = _enter(cm)
             ^^^^^^^^^^
/usr/local/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;unittest.mock._patch object at 0xffff7db84ad0&gt;

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
&gt;           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: &lt;module 'agent_core' from '/workspaces/build-your-first-agent-with-azure-ai-agent-service-workshop/src/python/workshop/agent_core.py'&gt; does not have the attribute 'chat'

/usr/local/lib/python3.13/unittest/mock.py:1467: AttributeError</failure></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_static_files_served" time="0.003" /><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_error_handling" time="0.001" /><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_api_update_event" time="0.002"><failure message="assert 404 == 200&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code">self = &lt;test_web_server_integration.TestWebServerIntegration object at 0xffff7da909f0&gt;
mock_update = &lt;AsyncMock name='async_update_event' id='281472780598448'&gt;
authenticated_client = &lt;FlaskClient &lt;Flask 'web_server'&gt;&gt;

    @patch('services.async_sql_store.async_update_event')
    def test_api_update_event(self, mock_update, authenticated_client):
        """Test event update API endpoint."""
        mock_update.return_value = {"success": True}
    
        event_id = "event-123"
        update_data = {
            "title": "Updated Meeting Title",
            "description": "Updated description"
        }
    
        response = authenticated_client.put(f'/api/events/{event_id}',
                                          data=json.dumps(update_data),
                                          content_type='application/json')
    
&gt;       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code

tests/integration/test_web_server_integration.py:240: AssertionError</failure></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_api_delete_event" time="0.002"><failure message="assert 404 == 200&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code">self = &lt;test_web_server_integration.TestWebServerIntegration object at 0xffff7da90c90&gt;
mock_cancel = &lt;AsyncMock name='async_cancel_event' id='281472775160560'&gt;
authenticated_client = &lt;FlaskClient &lt;Flask 'web_server'&gt;&gt;

    @patch('services.async_sql_store.async_cancel_event')
    def test_api_delete_event(self, mock_cancel, authenticated_client):
        """Test event deletion API endpoint."""
        mock_cancel.return_value = {"success": True}
    
        event_id = "event-123"
    
        response = authenticated_client.delete(f'/api/events/{event_id}')
    
&gt;       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code

tests/integration/test_web_server_integration.py:253: AssertionError</failure></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_api_rooms_with_artifacts" time="0.004"><failure message="assert 404 == 200&#10; +  where 404 = &lt;WrapperTestResponse 207 bytes [404 NOT FOUND]&gt;.status_code">self = &lt;test_web_server_integration.TestWebServerIntegration object at 0xffff7da1b380&gt;
mock_rooms = &lt;AsyncMock name='async_get_rooms' id='281472780598112'&gt;
authenticated_client = &lt;FlaskClient &lt;Flask 'web_server'&gt;&gt;
artifact_dir = PosixPath('reports/artifacts')
performance_tracker = &lt;conftest.performance_tracker.&lt;locals&gt;.PerformanceTracker object at 0xffff7d19fcb0&gt;

    @patch('services.async_sql_store.async_get_rooms')
    def test_api_rooms_with_artifacts(self, mock_rooms, authenticated_client, artifact_dir, performance_tracker):
        """Test rooms API endpoint with artifact collection and performance tracking."""
        # Start performance tracking
        performance_tracker.start_timer("api_rooms_request")
    
        mock_rooms.return_value = {
            "rooms": [
                {"id": "room1", "name": "Conference Room A", "capacity": 10},
                {"id": "room2", "name": "Conference Room B", "capacity": 6}
            ]
        }
    
        response = authenticated_client.get('/api/rooms')
    
        # End performance tracking
        performance_tracker.end_timer("api_rooms_request")
    
        # Save artifacts for analysis
        from tests.conftest import save_artifact
    
        if response.status_code != 200:
            save_artifact(artifact_dir, "rooms_api_error", response, "test_api_rooms_with_artifacts")
    
&gt;       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = &lt;WrapperTestResponse 207 bytes [404 NOT FOUND]&gt;.status_code

tests/integration/test_web_server_integration.py:281: AssertionError</failure></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_api_create_event_with_validation_artifacts" time="0.002"><failure message="assert 404 == 200&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code">self = &lt;test_web_server_integration.TestWebServerIntegration object at 0xffff7f89a150&gt;
mock_create = &lt;AsyncMock name='async_create_event' id='281472780593744'&gt;
authenticated_client = &lt;FlaskClient &lt;Flask 'web_server'&gt;&gt;
artifact_dir = PosixPath('reports/artifacts')

    @patch('services.async_sql_store.async_create_event')
    def test_api_create_event_with_validation_artifacts(self, mock_create, authenticated_client, artifact_dir):
        """Test event creation with validation error artifacts."""
        mock_create.return_value = {"success": False, "error": "Room conflict detected"}
    
        # Test with conflicting event data
        event_data = {
            "title": "Conflicting Meeting",
            "description": "This should conflict",
            "start_time": "2024-12-01T14:00:00Z",
            "end_time": "2024-12-01T15:00:00Z",
            "attendees": "user1@test.com,user2@test.com",
            "room_id": "room1"
        }
    
        response = authenticated_client.post('/api/events',
                                           data=json.dumps(event_data),
                                           content_type='application/json')
    
        from tests.conftest import save_artifact
    
        # This should be a validation error for our thesis analysis
        if response.status_code == 200:
            response_data = json.loads(response.data)
            if not response_data.get("success", True):
                save_artifact(artifact_dir, "event_creation_validation_error", {
                    "request_data": event_data,
                    "response": response_data,
                    "error_type": "business_logic_validation",
                    "error_message": response_data.get("error")
                }, "test_api_create_event_with_validation_artifacts")
    
&gt;       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code

tests/integration/test_web_server_integration.py:331: AssertionError</failure></testcase><testcase classname="tests.integration.test_web_server_integration.TestWebServerIntegration" name="test_api_error_handling_artifacts" time="0.005" /><testcase classname="tests.test_azure_eval" name="test_azure_evaluator" time="0.001"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="tests.test_fallback" name="test_fallback_evaluation" time="0.011" /><testcase classname="tests.test_organizer_permissions" name="test_organizer_permissions" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="tests.test_organizer_permissions" name="test_terminal_user_id_requirement" time="0.001"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="tests.test_scenarios" name="test_booking_scenarios" time="0.005" /><testcase classname="tests.test_setup" name="test_agent_core" time="0.001"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="tests.test_startup" name="test" time="0.000"><failure message="Failed: async def functions are not natively supported.&#10;You need to install a suitable plugin for your async framework, for example:&#10;  - anyio&#10;  - pytest-asyncio&#10;  - pytest-tornasync&#10;  - pytest-trio&#10;  - pytest-twisted">async def functions are not natively supported.
You need to install a suitable plugin for your async framework, for example:
  - anyio
  - pytest-asyncio
  - pytest-tornasync
  - pytest-trio
  - pytest-twisted</failure></testcase><testcase classname="tests.test_suite" name="test_imports" time="0.002" /><testcase classname="tests.test_suite" name="test_permission_system" time="0.001" /><testcase classname="tests.test_suite" name="test_data_loading" time="0.001" /><testcase classname="tests.test_suite" name="test_user_groups" time="0.001" /><testcase classname="tests.test_suite" name="test_group_rooms" time="0.001" /><testcase classname="tests.test_suite" name="test_utilities" time="0.001" /><testcase classname="tests.test_suite" name="test_calendar_service" time="0.002" /><testcase classname="tests.test_working_eval" name="test_working_evaluator" time="0.006" /><testcase classname="tests.unit.test_calendar_service.TestCalendarServiceInterface" name="test_interface_cannot_be_instantiated" time="0.001" /><testcase classname="tests.unit.test_calendar_service.TestCalendarServiceInterface" name="test_interface_methods_are_abstract" time="0.008"><failure message="AssertionError: assert frozenset({'c...edule_event'}) == {'check_room_..., 'get_rooms'}&#10;  &#10;  Extra items in the left set:&#10;  #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33mgenerate_synthetic_data#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33mschedule_event#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  &#10;  Full diff:&#10;  #x1B[0m#x1B[91m- {#x1B[39;49;00m#x1B[90m#x1B[39;49;00m...&#10;  &#10;  ...Full output truncated (8 lines hidden), use '-vv' to show">self = &lt;test_calendar_service.TestCalendarServiceInterface object at 0xffff7d472c10&gt;

    def test_interface_methods_are_abstract(self):
        """Test that all interface methods are abstract."""
        abstract_methods = CalendarServiceInterface.__abstractmethods__
        expected_methods = {"get_events", "get_rooms", "check_room_availability"}
&gt;       assert abstract_methods == expected_methods
E       AssertionError: assert frozenset({'c...edule_event'}) == {'check_room_..., 'get_rooms'}
E         
E         Extra items in the left set:
E         #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33mgenerate_synthetic_data#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E         #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33mschedule_event#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E         
E         Full diff:
E         #x1B[0m#x1B[91m- {#x1B[39;49;00m#x1B[90m#x1B[39;49;00m...
E         
E         ...Full output truncated (8 lines hidden), use '-vv' to show

tests/unit/test_calendar_service.py:30: AssertionError</failure></testcase><testcase classname="tests.unit.test_calendar_service.TestMockCalendarService" name="test_get_rooms_returns_json_string" time="0.001" /><testcase classname="tests.unit.test_calendar_service.TestMockCalendarService" name="test_get_events_empty_result" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service.TestMockCalendarService object at 0xffff7d472d50&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service.TestMockCalendarService" name="test_get_events_with_data" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service.TestMockCalendarService object at 0xffff7d4596e0&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service.TestMockCalendarService" name="test_get_events_filtered_by_room" time="0.001"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service.TestMockCalendarService object at 0xffff7d459810&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service.TestMockCalendarService" name="test_check_room_availability_available" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service.TestMockCalendarService object at 0xffff7d4ba690&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service.TestMockCalendarService" name="test_check_room_availability_conflict" time="0.001"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service.TestMockCalendarService object at 0xffff7d435590&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service.TestMockCalendarService" name="test_check_room_availability_no_conflict_different_room" time="0.001"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service.TestMockCalendarService object at 0xffff7d435ae0&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service.TestMockCalendarService" name="test_room_data_structure" time="0.001"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service.TestMockCalendarService object at 0xffff7d5c3150&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service.TestMockCalendarService" name="test_concurrent_availability_checks" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service.TestMockCalendarService object at 0xffff7d5c3750&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service.TestMockCalendarService" name="test_get_events_with_room_filter" time="0.001" /><testcase classname="tests.unit.test_calendar_service.TestMockCalendarService" name="test_check_room_availability_returns_json_string" time="0.001" /><testcase classname="tests.unit.test_calendar_service_clean.TestCalendarServiceInterface" name="test_interface_cannot_be_instantiated" time="0.000" /><testcase classname="tests.unit.test_calendar_service_clean.TestCalendarServiceInterface" name="test_interface_methods_are_abstract" time="0.001"><failure message="AssertionError: assert frozenset({'c...edule_event'}) == {'check_room_..., 'get_rooms'}&#10;  &#10;  Extra items in the left set:&#10;  #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33mgenerate_synthetic_data#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33mschedule_event#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  &#10;  Full diff:&#10;  #x1B[0m#x1B[91m- {#x1B[39;49;00m#x1B[90m#x1B[39;49;00m...&#10;  &#10;  ...Full output truncated (8 lines hidden), use '-vv' to show">self = &lt;test_calendar_service_clean.TestCalendarServiceInterface object at 0xffff7d472fd0&gt;

    def test_interface_methods_are_abstract(self):
        """Test that all interface methods are abstract."""
        abstract_methods = CalendarServiceInterface.__abstractmethods__
        expected_methods = {"get_events", "get_rooms", "check_room_availability"}
&gt;       assert abstract_methods == expected_methods
E       AssertionError: assert frozenset({'c...edule_event'}) == {'check_room_..., 'get_rooms'}
E         
E         Extra items in the left set:
E         #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33mgenerate_synthetic_data#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E         #x1B[0m#x1B[33m'#x1B[39;49;00m#x1B[33mschedule_event#x1B[39;49;00m#x1B[33m'#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E         
E         Full diff:
E         #x1B[0m#x1B[91m- {#x1B[39;49;00m#x1B[90m#x1B[39;49;00m...
E         
E         ...Full output truncated (8 lines hidden), use '-vv' to show

tests/unit/test_calendar_service_clean.py:30: AssertionError</failure></testcase><testcase classname="tests.unit.test_calendar_service_clean.TestMockCalendarService" name="test_get_rooms_returns_json_string" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service_clean.TestMockCalendarService object at 0xffff7d473110&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service_clean.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service_clean.TestMockCalendarService" name="test_get_events_empty_result" time="0.001"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service_clean.TestMockCalendarService object at 0xffff7d473250&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service_clean.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service_clean.TestMockCalendarService" name="test_get_events_with_data" time="0.000"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service_clean.TestMockCalendarService object at 0xffff7d459940&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service_clean.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service_clean.TestMockCalendarService" name="test_check_room_availability_available" time="0.001"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service_clean.TestMockCalendarService object at 0xffff7d459a70&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service_clean.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_calendar_service_clean.TestMockCalendarService" name="test_check_room_availability_conflict" time="0.001"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'&quot;">self = &lt;test_calendar_service_clean.TestMockCalendarService object at 0xffff7d4e95b0&gt;

    @pytest.fixture
    def calendar_service(self):
        """Create MockCalendarService instance."""
&gt;       return MockCalendarService()
               ^^^^^^^^^^^^^^^^^^^^^
E       TypeError: Can't instantiate abstract class MockCalendarService without an implementation for abstract methods 'generate_synthetic_data', 'schedule_event'

tests/unit/test_calendar_service_clean.py:75: TypeError</error></testcase><testcase classname="tests.unit.test_shared_thread_manager.TestSharedThreadManager" name="test_create_shared_thread" time="0.002" /><testcase classname="tests.unit.test_shared_thread_manager.TestSharedThreadManager" name="test_get_shared_thread" time="0.001" /><testcase classname="tests.unit.test_shared_thread_manager.TestSharedThreadManager" name="test_delete_shared_thread" time="0.001" /><testcase classname="tests.unit.test_shared_thread_manager.TestSharedThreadManager" name="test_list_user_threads" time="0.002" /><testcase classname="tests.unit.test_shared_thread_manager.TestSharedThreadManager" name="test_thread_permissions" time="0.002" /><testcase classname="tests.unit.test_shared_thread_manager.TestSharedThreadManager" name="test_thread_validation" time="0.001" /><testcase classname="tests.unit.test_shared_thread_manager.TestSharedThreadManager" name="test_concurrent_thread_access" time="0.001" /><testcase classname="tests.unit.test_shared_thread_manager.TestSharedThreadManager" name="test_thread_message_history" time="0.002" /><testcase classname="tests.unit.test_sql_store.TestAsyncSQLStore" name="test_async_get_rooms" time="15.163"><failure message="pyodbc.OperationalError: ('HYT00', '[HYT00] [Microsoft][ODBC Driver 18 for SQL Server]Login timeout expired (0) (SQLDriverConnect)')">self = &lt;test_sql_store.TestAsyncSQLStore object at 0xffff7d473890&gt;

    @pytest.mark.asyncio
    async def test_async_get_rooms(self):
        """Test async wrapper for get_rooms."""
        expected_rooms = {"rooms": [{"id": "room1", "name": "Conference Room A"}]}
    
        with patch('services.compat_sql_store.get_rooms', return_value=expected_rooms):
&gt;           result = await async_get_rooms()
                     ^^^^^^^^^^^^^^^^^^^^^^^

tests/unit/test_sql_store.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
services/async_sql_store.py:11: in async_get_rooms
    return await asyncio.to_thread(get_rooms)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.13/asyncio/threads.py:25: in to_thread
    return await loop.run_in_executor(None, func_call)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/local/lib/python3.13/concurrent/futures/thread.py:59: in run
    result = self.fn(*self.args, **self.kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
services/compat_sql_store.py:12: in get_rooms
    with _conn() as cn, cn.cursor() as cur:
         ^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def _conn():
&gt;       return pyodbc.connect(CS)
               ^^^^^^^^^^^^^^^^^^
E       pyodbc.OperationalError: ('HYT00', '[HYT00] [Microsoft][ODBC Driver 18 for SQL Server]Login timeout expired (0) (SQLDriverConnect)')

services/compat_sql_store.py:8: OperationalError</failure></testcase><testcase time="0.002" /></testsuite></testsuites>